ğŸ”ğŸ—ï¸ We see that there's only the object is created in PostsModel, for this there is no array or list exist,that's why we have to initialize the array or list in our code.And make a custom list:
Go to the home page ->
write the code of Future function under class:



.......................
class _HomScreenState extends State<HomScreen> {
  List<PostsModel> postList = [];

  Future<List<PostsModel>> getPostApi() async {
    final response = await http.get(Uri.parse('https://jsonplaceholder.typicode.com/posts'));
    var data = jsonDecode(response.body.toString());

    if (response.statusCode == 200) {
      for (Map i in data) {
        postList.add(PostsModel.fromJson(i));
      }
      return postList;
    } else {
      return postList;
    }
  }
  @override
  Widget build(BuildContext context) {
    return Scaffold();
  }
}....................


ğŸ”ğŸ—ï¸  Full description of this code:


âœ¨ class _HomScreenState extends State<HomScreen> { âœ¨

This defines a class _HomScreenState that extends State<HomScreen>, meaning it is a stateful widget.
HomScreen is presumably a screen widget in the app.
The underscore (_) before the class name means it is private to the file.


âœ¨ List<PostsModel> postList = []; âœ¨

This declares a list named postList, which will hold objects of type PostsModel.
It is initially empty and will later store data fetched from an API.


âœ¨ Future<List<PostsModel>> getPostApi() async { âœ¨

This function getPostApi() is an asynchronous function (async keyword) that fetches data from an API.
It returns a Future<List<PostsModel>>, meaning it will eventually return a list of PostsModel objects.


âœ¨ final response = await http.get(Uri.parse('https://jsonplaceholder.typicode.com/posts')); âœ¨

This line makes an HTTP GET request to the API https://jsonplaceholder.typicode.com/posts.
The await keyword is used to wait for the response from the API before moving to the next line.


âœ¨ var data = jsonDecode(response.body.toString()); âœ¨

response.body contains the raw JSON response from the API.
jsonDecode(response.body.toString()) converts this JSON string into a Dart object, usually a List<Map>.


âœ¨ if (response.statusCode == 200) { âœ¨

This checks if the API request was successful.
A statusCode of 200 means the request was successful and data was received.


âœ¨ for (Map i in data) { 
  postList.add(PostsModel.fromJson(i));
} âœ¨

This loops through each element (Map i) in data (which is a list of JSON objects).
PostsModel.fromJson(i) converts each JSON object into a PostsModel instance.
The converted object is then added to the postList.


âœ¨ return postList; âœ¨

After processing the data, the function returns the postList, which now contains a list of PostsModel objects.


âœ¨ } else { 
  return postList;
} âœ¨

If the response status is not 200 (meaning there was an error), it simply returns the empty postList.


âœ¨ @override
Widget build(BuildContext context) {
  return Scaffold();
} âœ¨

This is the build method, which returns a Scaffold widget (an empty screen for now).
Scaffold is a basic structure in Flutter that provides a layout for app screens.


ğŸ”ğŸ—ï¸ How the Code Works:

When the screen (widget) is initialized, postList is an empty list.
The getPostApi() function is called asynchronously to fetch data from the API.
The API response is received and decoded into a Dart object.
If the response is successful (statusCode == 200):
It loops through the JSON data.
Converts each JSON object into a PostsModel object.
Adds each object to postList.
Returns the updated list.
If the response is not successful, it simply returns an empty list.
The build method returns an empty screen (Scaffold), but this can be expanded to display the postList in a widget like ListView.

ğŸ”ğŸ—ï¸ Potential Improvements:
Handle API errors properly (e.g., show an error message).
Use setState to update the UI after fetching data.
Display the fetched posts in a UI widget like ListView.builder().


ğŸ”ğŸ—ï¸ For this our API is hit in our flutter project.
ğŸ—ï¸ 6.Now we have to show this API:

Write the code under body:

......................
@override
Widget build(BuildContext context) {
  return Scaffold(
    appBar: AppBar(
      title: Text("Api Course"),
    ), // AppBar

    body: Column(
      children: [
        Expanded(
          child: FutureBuilder(
            future: getPostApi(),
            builder: (context, snapshot) {
              if (!snapshot.hasData) {
                return Text("Loading...");
              } else {
                return ListView.builder(
                  itemCount: postList.length,
                  itemBuilder: (context, index) {
                    return Text(postList[index].title.toString());
                  },
                );
              }
            },
          ), // FutureBuilder
        ), // Expanded
      ],
    ), // Column
  ); // Scaffold
}
...........................


ğŸ”ğŸ—ï¸  Full description of this code:

1ï¸âƒ£ body: Column(
This defines the body of the Scaffold widget and uses a Column to structure the UI vertically.
2ï¸âƒ£ children: [
The Column widget takes a list of children, meaning multiple widgets can be added inside it.
3ï¸âƒ£ Expanded(
This ensures that the child widget (inside Expanded) takes all available space.
4ï¸âƒ£ child: FutureBuilder(
FutureBuilder is used to handle asynchronous data fetching. It waits for the API response and updates the UI accordingly.
5ï¸âƒ£ future: getPostApi(),
The future parameter is assigned the function getPostApi(), which fetches data from an API.
6ï¸âƒ£ builder: (context, snapshot) {
The builder function defines how the UI should be built based on the state of snapshot, which holds the response of the future (getPostApi()).
7ï¸âƒ£ if (!snapshot.hasData) {
This checks if the snapshot has no data, meaning the API call is still in progress.
8ï¸âƒ£ return Text("Loading...");
If data is not available yet, it shows a "Loading..." message.
9ï¸âƒ£ } else {
Once data is available, execution moves to this block.
ğŸ”Ÿ return ListView.builder(
ListView.builder dynamically creates a scrollable list based on the API data.
1ï¸âƒ£1ï¸âƒ£ itemCount: postList.length,
Specifies the number of items in the list, based on the length of postList, which contains the fetched API data.
1ï¸âƒ£2ï¸âƒ£ itemBuilder: (context, index) {
This function builds each item in the list, iterating through postList using an index.
1ï¸âƒ£3ï¸âƒ£ return Text(postList[index].title.toString());
Displays each postâ€™s title as a Text widget. The title is converted to a string to ensure it is displayed correctly.

ğŸ”ğŸ—ï¸ Working Process of the Code:
âœ¨Starts Execution

âœ¨The FutureBuilder calls getPostApi() to fetch data from an API.
âœ¨Displays Loading Message

âœ¨While waiting for data, snapshot.hasData is false, so "Loading..." is displayed.
âœ¨Receives API Data

âœ¨Once the API response is received, snapshot.hasData becomes true.
âœ¨Builds ListView

âœ¨ListView.builder creates a dynamic list using postList.length, displaying each title in a Text widget.

ğŸ”ğŸ—ï¸ Final Output:
Before Data Loads â†’ Shows "Loading...".
After Data Loads â†’ Displays a list of titles fetched from the API.


ğŸ”ğŸ—ï¸ To arrange more suitable form write this in reuturn with explanation :

